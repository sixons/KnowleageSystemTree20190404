Spring事务的传播特性

所谓事务的嵌套就是两个事务方法之间相互调用。spring事务开启 ，或者是基于接口的或者是基于类的代理被创建（注意一定要是代理，不能手动new 一个对象，并且此类（有无接口都行）一定要被代理——spring中的bean只要纳入了IOC管理都是被代理的）。

所谓事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。Spring 支持 7 种事务传播行为（Transaction Propagation Behavior）：

传播行为	描述
PROPAGATION_REQUIRED	如果没有，就开启一个事务；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）
RROPAGATION_REQUIRES_NEW	如果没有，就开启一个事务；如果有，就将当前事务挂起。（方法A所在的事务就会挂起，方法B会起一个新的事务，等待方法B的事务完成以后，方法A才继续执行）
PROPAGATION_NESTED	如果没有，就开启一个事务；如果有，就在当前事务中嵌套其他事务
PROPAGATION_SUPPORTS	如果没有，就以非事务方式执行；如果有，就加入当前事务（方法B看到自己已经运行在 方法A的事务内部，就不再起新的事务，直接加入方法A）
PROPAGATION_NOT_SUPPORTED	如果没有，就以非事务方式执行；如果有，就将当前事务挂起，（方法A所在的事务就会挂起，而方法B以非事务的状态运行完，再继续方法A的事务）
PROPAGATION_NEVER	如果没有，就以非事务方式执行；如果有，就抛出异常。
PROPAGATION_MANDATORY	如果没有，就抛出异常；如果有，就使用当前事务

其中前4种是开发中用到概率比较大的，建议熟记；后面3种不常用，了解就行。

我们经常会提到，方法A传播到方法B，那到底是A调用B，还是B调用A，这个问题我一开始学Spring的时候犯浑过，搞反了，导致久久理解不了。其实只要仔细斟酌字面意思就不会像我那样犯傻了。

A传播到B，显而易见进入A方法执行半途中，再次进入B方法，这才叫做传播到方法B中。